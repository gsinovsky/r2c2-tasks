# -*- coding: utf-8 -*-
import datetime

from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, BigInteger, and_
from sqlalchemy.dialects.postgresql import TIMESTAMP, DOUBLE_PRECISION
from sqlalchemy.orm import relationship, backref
from twitterAPI import TwitterAPIFactory

from db import Base, session
from utils import parse_datetime_from_str
class User(Base):
    """Modelo para usuario de Twitter"""
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, autoincrement=True)
    # id de este usuario
    user_id = Column(String, unique=True) # json: id

    screen_name = Column(String(200, convert_unicode=True), unique=True) # json

    # tweets que estamos tracking
    tweets = relationship('Tweet', backref='user')

    def __init__(self, *args, **kwargs):
        for k, w in kwargs.items():
            setattr(self, k, w)

    @classmethod
    def from_api(cls, user):
        payload = user.AsDict()
        payload['user_id'] = str(payload['id'])
        del payload['id']
        instance = cls(**payload)
        return instance

    @classmethod
    def get_or_create(cls, user):
        instance = User.query.filter(User.user_id==str(user.id)).first()
        if instance is not None:
            return instance
        instance = cls.from_api(user)
        session.add(instance)
        session.commit()
        return instance

    @classmethod
    def from_twitterAPI(cls,TwitterAPI,user_id):
        twitterUser = TwitterAPI.GetUser(user_id=user_id)
        return cls.get_or_create(twitterUser)

    @classmethod
    def from_dictionary(cls,user_dict):
        user_id = None
        if 'id' in user_dict: user_id = user_dict['id']
        if 'user_id' in user_dict: user_id = user_dict['user_id']

        twitterAPIFactory = TwitterAPIFactory()
        TwitterAPI = twitterAPIFactory.getAPI()
        return cls.from_twitterAPI(TwitterAPI=TwitterAPI,user_id=user_id)

    def __str__(self):
        return '@{}'.format(self.screen_name)



    __repr__ = __str__

class Tweet(Base):
    """Modelo de tweets."""
    __tablename__ = 'tweets'
    id = Column(Integer, primary_key=True, autoincrement=True)
    # fechas cuando publicaron el tweet y cuando lo jalamos
    created_at = Column(DateTime, default=datetime.datetime.now) # json
    # identificador del tweet en twitter
    tweet_id = Column(String(convert_unicode=True), unique=True) # json: id
    # contenido del tweet
    text = Column(String(250, convert_unicode=True))
    # usuario que publica
    user_id = Column(Integer, ForeignKey('users.id'))

    def __init__(self, *args, **kwargs):
        for k, w in kwargs.items():
            setattr(self, k, w)

    @classmethod
    def from_api(cls, tweet):
        payload = tweet.AsDict()
        payload['tweet_id'] = str(payload['id'])
        del payload['id']
        del payload['user']
        payload['user_id'] = User.get_or_create(tweet.user).id
        payload['created_at'] = parse_datetime(tweet)
        instance = cls(**payload)
        return instance

    @classmethod
    def create(cls, tweet):
        instance = cls.from_api(tweet)
        session.add(instance)
        session.commit()
        return instance

    @classmethod
    def from_dictionary(cls,twitter_dict):
        payload = twitter_dict
        payload['tweet_id'] = str(payload['id'])
        userAsDict = payload['user'] 

        modelUser =  User.from_dictionary(userAsDict)
        payload['user_id'] = modelUser.id
        payload['user'] = modelUser

        del payload['id'] #id key needs to be deleted because its value is autogenerated 
        payload['created_at'] = parse_datetime_from_str(payload['created_at'])

        instance = cls(**payload)

        return instance

    def submit(self):
        session.add(self)
        session.commit()

    def __str__(self):
        return u'{}\'s tweet #{}'.format(self.user, self.tweet_id)

    __repr__ = __str__


class Route(Base):

    __tablename__ = 'route'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    # Arco en el grafo
    origin = Column(String) 
    destination = Column(String)

    def __init__(self, *args, **kwargs):
        for k, w in kwargs.items():
            setattr(self, k, w)

    def save(self):
        session.add(self)
        session.commit()

    @classmethod
    def get_or_none(cls,origin,destination):
        return Route.query.filter(and_(Route.origin==origin, Route.destination==destination)).first()
    
    def __str__(self):
        return "Route(id=%s,origin=%s,destination=%s)"%(self.id, self.origin,self.destination)

    __repr__ = __str__


class HistoricScore(Base):
    """Modelo para el costo de los arcos"""
    __tablename__ = 'historic_score'

    route_id = Column(Integer,ForeignKey('route.id'), primary_key=True)#Referenec to Route
    timestamp = Column(TIMESTAMP(timezone=False), primary_key=True)
    score = Column(DOUBLE_PRECISION)

    def __init__(self, *args, **kwargs):
        for k, w in kwargs.items():
            setattr(self, k, w)

    def save(self):
        session.add(self)
        session.commit()

    @classmethod
    def get_or_none(cls,route_id,timestamp):
        return cls.query.filter(and_(cls.route_id==route_id,cls.timestamp==timestamp)).first()

    @classmethod
    def get_scores_from_date(cls,route_id,timestamp):
        return cls.query.filter(and_(cls.route_id==route_id,cls.timestamp >= timestamp))

    @classmethod
    def get_scores_until_date(cls,route_id,timestamp):
        return cls.query.filter(and_(cls.route_id==route_id,cls.timestamp <= timestamp))

    @classmethod
    def get_scores_between_dates(cls,route_id,lower_timestamp,higher_timestamp):
        return cls.query.filter(and_(cls.route_id==route_id,cls.timestamp >= lower_timestamp,cls.timestamp <= higher_timestamp)).all()

    def __str__(self):
        return "HistoricScore(route_id=%s,timestamp=%s,score%s)"%(self.route_id,self.timestamp,self.score)

    __repr__ = __str__

